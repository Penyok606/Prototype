Призначення
Задає види об'єктів, що створюються, за допомогою екземпляру-прототипу, та створює нові об'єкти шляхом копіювання цього прототипу.

Шаблон проектування Прототип дозволяє вирішити такі проблеми як: [3]

Як об'єкти можуть створюватися у такий спосіб?, що те, який об'єкт буде створено може бути визначено під час виконання коду?
Як можна створити екземпляри динамічно завантажених об'єктів?
Створення нових об'єктів напряму за допомогою класу, що потребує (використовує) певні об'єкти є не достатньо гнучким, оскільки змушує прив'язати клас до певних об'єктів під час компіляції, і стає неможливо визначити які об'єкти будуть створені під час виконання коду.

Шаблон проектування прототип визначає спосіб, як вирішити цю задачу:

Визначити об'єкт Prototype (прототип), що створює копію самого себе.
Створити новий об'єкт шляхом копіювання об'єкту Prototype.
Це дозволяє створювати конфігурації класу із різними об'єктами прототипу Prototype, які будуть копіюватися для створення нових об'єктів, і навіть більше, об'єкти Prototype можуть додаватися і знищуватися під час виконання.
Застосування
Слід використовувати шаблон Прототип коли:

класи, що інстанціюються, визначаються під час виконання, наприклад за допомогою динамічного завантаження;
треба запобігти побудові ієрархій класів або фабрик, паралельних ієрархій класів продуктів;
екземпляри класу можуть знаходитись у одному з не дуже великої кількості станів. Може статися, що зручніше встановити відповідну кількість прототипів та клонувати їх, а не інстанціювати щоразу клас вручну в слушному стані.
Емпіричні правила
Іноді твірні шаблони збігаються один з одним — існують випадки, коли більш доречно використовувати або прототип або абстрактну фабрику. А в інших випадках вони доповнюють один одного: абстрактна фабрика може зберігати множину прототипів, з яких буде створюватися копія і повертатимуться утворені об'єкти (GoF, с. 126). Абстрактна фабрика, будівник, і прототип можуть в своїй реалізації використовувати шаблон Одинак. (GoF, сc. 81, 134). Класи абстрактних фабрик часто реалізовані за допомогою фабричних методів (створення через успадкування), але вони можуть також реалізовуватися за допомогою прототипу (створення шляхом делегування[en]). (GoF, с.95)

Часто, проектування починається із використання фабричного методу (менш складно, піддається кращому налаштовуванню, поширюється на підкласи) і еволюціонує в сторону абстрактної фабрики, прототипу, або будівника (більш гнучкі і більш складні) якщо архітектор коду виявляє де потребується більша гнучкість поведінки. (GoF, с.136)

Прототип не потребує створення підкласів, але потребує процедури «ініціалізації». Фабричний метод потребує створення підкласів, але не потребу ініціалізації. (GoF, с. 116)

Архітектури, які широко використовують шаблони компонувальник та декоратор, також можуть отримати вигоду із використання прототипу. (GoF, с.126)

Емпіричне правило може полягати в тому, що вам може знадобитися метод копіювання clone() Об'єкту коли ви хочете створити інший об'єкт під час виконання коду, який є повною копією того об'єкта, що ви копіюєте. Повна копія означає, що всі атрибути новоствореного об'єкту будуть такими ж самими, як і в того об'єкта який ви клонуєте. Якби замість цього ви створювали екземпляр даного класу використовуючи ключове слово new, ви б отримали об'єкт із атрибутами, що мають початкові не задані значення.

Наприклад, якщо ви використовуєте систему, що здійснює транзакції із банківським рахунком, тобі б вам знадобилося створити копію об'єкту, що зберігає в собі інформацію про цей рахунок, здійснити над ним транзакцію, а потім замінити оригінальний об'єкт на змінений. В даному випадку ви б захотіли використати метод clone() замість new.

#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Prototype
{
	virtual Prototype* Clone() = 0;
};

class Item : public Prototype
{
public:
	int ID;
	string Name;
public:
	Item(string strName) : Name(strName)
	{
		ID = GetNewID();
	};
	// конструктор копіювання
	Item(Item& item) : Name(item.Name) 
	{
		ID = GetNewID();
	};
	virtual ~Item() { };

	virtual Prototype* Clone()
	{
		return new Item(*this);
	};

	static int GetNewID()
	{
		static int ID = 0;
		return ++ID;
	};
};

void print(Prototype* p)
{
	Item* pItem = dynamic_cast <Item*> (p);

	cout << "ID: " << pItem->ID << endl;
	cout << "Name: " << pItem->Name << endl;
	cout << endl;
}

void main()
{
	vector<Prototype*> items;
	Item Item("Concrete Item");

	// клонуємо об'єкт
	for (int i = 0; i < 10; ++i)
	{
		items.push_back
		(
			Item.Clone() // виклик методу клонування
		);
	}
	// Друкуємо клонів
	for (int i = 0; i < 10; ++i)
	{
		print(items[i]);
	}
}
